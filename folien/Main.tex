\documentclass[12pt,utf8]{beamer}
\setbeamercovered{transparent}
\usepackage[german]{babel}
\usepackage{color}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\input{beamerthemeTU.sty}

\title{Linux Basic}
\subtitle{Das Terminal}

\author[J.-M. Lenk, C. Parnitzke, Y. Bungers]{Jan-Marius Lenk, Christoph Parnitzke, Yannick Bungers}
\institute[FOSS AG]{Free and Open Source Software AG\\ Fakultät für Informatik}

\date{\today}

\begin{document}

\titlepage

\begin{frame}
\frametitle{Inhaltsverzeichnis}
\begin{itemize}
	\item Theorie
	\item Arbeiten mit Ordnern, Dateien und Archiven
	\item Prozesse
	\item Zusatz
\end{itemize}
\end{frame}

\section{Theorie}
\begin{frame}
\frametitle{Linux Philosophie}
\begin{figure}
\includegraphics[scale=0.3]{res/tux.png}
\end{figure}
\begin{itemize}
	\item Philosophie besteht aus drei Punkten:
	\begin{itemize}
		\item 1. Schreibe Programme, die nur eine Sache tun und dies erfolgreich (DOTADIW)
		\item 2. Schreibe Programme um zusammen zu Arbeiten
		\item 3. Schreibe Programme, die mit Text arbeiten, denn dies ist universell
	\end{itemize}
	\item Ist auch heute noch Kernaussage
\end{itemize}
\footnote{https://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png}
\end{frame}

\begin{frame}
\frametitle{Terminal vs. Shell}
\begin{itemize}
	\item Terminal ist zeilenweise Eingabe von Befehlen
	\begin{itemize}
		\item[1)] TTY (teletype) sind Terminals, erreichbar via STRG+ALT+F[1-7]
		\item[2)] VTerm: virtueller Terminal in grafischer Oberfläche
		\item[3)] Shell: interpretiert Eingabe des Benutzers
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{s}witch \textcolor{red}{u}ser}
\begin{itemize}
	\item Wechsel des Benutzers innerhalb der Konsole
	\item Ohne Parameter wird versucht sich als 'root' einzuloggen
	\item Ansonsten 'su [user]' einloggen als 'user'
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{s}uper \textcolor{red}{u}ser \textcolor{red}{do}}
\framesubtitle{Mit großer Macht kommt große Verantwortung}
'sudo' führt einen Befehl mit administrativer Berechtigung aus 'sudo [command]'.
[Achtung!!] 'sudo' funktioniert nur, wenn Benutzer in root-Gruppe ist.
\begin{itemize}[<+->]
	\item Führt man Befehle als Root aus, sollte man vorsichtig sein
	\item Parameter:
	\begin{itemize}[<+->]
		\item '-b' (background) führt Befehl im Hintergrund aus [kommt später]
		\item '-e' (edit) öffnet Datei zum editieren, erstellt temp. Backup
		\item '-s' (shell) öffnet eine Shell
		\item '-u [user]' führt Befehl als [user] aus
	\end{itemize}
	\item Wird hier'[nur Root]' angegeben, muss Befehl mit sudo gestartet werden
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{apt-get vs. apt vs. aptitute}
[nur Root]
\begin{itemize}
	\item Paket Management: apt Kurzform für apt-get und apt-cache
	\item Wichtigsten Befehle:
	\begin{itemize}
		\item[1.] 'apt install [pkg...]'
		\item[2.] 'apt update'
		\item[3.] 'apt [upgrade | dist-upgrade | full-upgrade]'
		\item[4.] 'apt remove [pkg...]'
	\end{itemize}
	\item 'aptitude' ist etwas grafischer und hat Zusatzfunktionen
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{man page}
\framesubtitle{Wenn man mal nicht weiter weiß}
Die Man-Page ist die Benutzeranleitung des Systems, mit Anleitungen zur Benutzung der installierten Programme
\begin{itemize}
	\item Sektionen, die besonders interessant sind:
	\begin{itemize}
		\item {\scriptsize NAME, SYNOPSIS, DESCRIPTION, OPTIONS (EXAMPLE und BUGS)}
	\end{itemize}
	\item \textbf{Wie werden Einträge gesucht?}
	\begin{itemize}
		{
		\footnotesize
		\item ausführbare Programme und Shell Kommandos
		\item Systemaufrufe (vom Kernel bereit gestellt)
		\item Bibliotheksaufrufe (Programm-Bibliotheken)
		\item spezielle Dateien (in /dev)
		\item Dateiformate und Konventionen (/etc/passwd)
		\item Spiele
		\item Sonstiges (Macropakete und Konventionen)
		\item System administrations Kommandos (nur Root)
		\item Kernel Routinen (kein Standard)
		}
	\end{itemize}
\end{itemize}
\end{frame}

%autocompletion einfach erwähnen und als notiz auf Handout
\begin{frame}
\frametitle{Aufgabe 1}
Nun sollt ihr euch ein wenig mit der man-Page und dem Paket-Management vertraut machen. Zur Bearbeitung dieser Aufgabe habt ihr 10 Minuten zeit.
\begin{itemize}
	\item[1)] führt ein Update der Quellen durch; 'apt update'
	\item[2)] installiert das Paket 'funny-manpages'
	\begin{itemize}
		\item benutzt dazu 'apt install'
		\item 'sudo' nicht vergessen!!
	\end{itemize}
	\item[3)] betrachtet folgende man-Pages:
	\begin{itemize}
		\item 'su', 'apt-get', 'party', 'uubp', 'tm', 'flog'
	\end{itemize}
	\item[4)] (optional) 'funny-manpages' entfernen, wer mag
	\begin{itemize}
		\item benutzt dazu apt remove
	\end{itemize}
\end{itemize} 
\end{frame}

\section{Arbeiten mit Ordnern, Dateien und Archiven}
\subsection{Ordner}
\begin{frame}
\frametitle{\textcolor{red}{l}i\textcolor{red}{s}t}
\framesubtitle{Ein kleines Licht in der Dunkelheit}
\begin{itemize}
	\item Listet alle Ordner und Dateien in Verzeichnis auf
	\item Aktuelles Verzeichnis ist dabei Default
	\item Mögliche Argumente:
	\begin{itemize}[<+->]
		\item '-a'  (all) inkl. versteckter Verzeichnisse
		\item '-l'  (long listing format) inkl. Rechte, Besitzer, Größe, etc.
		\item '-h'  (human readable) Größen der Dateien leserlicher
		\item '-r'  (recursive) umgekehrte Reihenfolge
		\item '-m'  Namen durch Kommata getrennt
	\end{itemize}
	\item Bsp.: 'ls -al'
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{c}hange \textcolor{red}{d}irectory}
\framesubtitle{Die kleine Form der Teleportation}
'cd' bietet das Navigieren durch das Dateisystem
\begin{itemize}[<+->]
	\item Notationen:	
	\begin{itemize}[<+->]
		\item Wechsel in Parent-Directory mit '../'
		\item Wechsel in Home-Directory mit 'cd'   (ohne Pfad)
		\item Wechsel in Verzeichnis (Bsp.: Dokumente (bzw. Documents))
		\begin{itemize}[<+->]
			\item 'cd /home/[username]/Dokumente'
			\item 'cd $\sim$/Dokumente'   (Abkürzen von Home-Directory mit $\sim$)
			\item 'cd Dokumente'    (relativ vom aktuellen Verzeichnis)
		\end{itemize}
	\end{itemize}
	\item Funfact: 'cd .'  (wechselt in das aktuelle Verzeichnis)
	\begin{itemize}
		\item es tut nichts, aber dafür sehr gut
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{m}a\textcolor{red}{k}e \textcolor{red}{dir}ectory}
\framesubtitle{Verzeichnisse erschaffen}
'mkdir' erstellt Ordner auf dem Rechner
\begin{itemize}[<+->]
	\item Syntax: 'mkdir [path]'   (erzeugt Ordner mit Pfad [path])
	\item Beispiel:
	\begin{itemize}[<+->]
		\item 'mkdir neuer-ordner/'    (relativ zum aktuellen Pfad)
		\item 'mkdir /tmp/neuer-ordner/tmp1/tmp2/'
	\end{itemize}
	\item '-p'   erstellt Parent-Directory, falls es nicht existiert
	\item '-mode=[mode]'  Modus mit dem der Ordner erstellt wird (siehe chmod)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Gruppenverwaltung}
\begin{itemize}[<+->]
	\item 'groups [username]' (zeigt Gruppen von Benutzer an)
	\item 'groupadd [groupname]' (legt Gruppe an) [nur Root]
	\item 'groupdel [groupname]' (löscht Gruppe) [nur Root]
	\item 'groupmod [option] [groupname]' (Bsp.: --new-name [Name]) [nur Root]
	\item 'usermod -aG [username] [groupname]' (Benutzer zu Gruppe hinzufügen) [nur Root]
	\item 'deluser [username] [groupname]' (Benutzer aus Gruppe entfernen) [nur Root]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{ch}ange \textcolor{red}{mod}e}
\framesubtitle{Mein Ordner gehört mir}
'chmod' ändert die Zugriffsrechte von Dateien und Ordnern
\begin{itemize}[<+->]
	\item Syntax: 'chmod [mode] [path]'
	\item Beispiel (/home/[username]/neuer-ordner/):
	\begin{itemize}[<+->]
		\item aktuelle Rechte: u=rwx g=r-x a=r-x
		\item 'chmod g=rwx $\sim$/neuer-ordner' (wir geben der Gruppe Schreib-Recht)
		\item 'chmod a-r $\sim$/neuer-ordner' (wir nehmen allen anderen das Lese-Recht)
		\item neue Rechte: u=rwx g=rwx a=--x
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{ch}ange \textcolor{red}{own}er}
Ändern des Besitzers von Orndern und Dateien.
\begin{itemize}
	\item Zu jeder Datei/Ordner gehören 2 Besitzer:
	\begin{itemize}[<+->]
		\item ein Nutzer
		\item eine Gruppe
	\end{itemize}
	\item 'chown [user] [file]' [file] gehört jetzt [user]
	\item 'chown [user]:[group] [file]' [file] gehört jetzt zu [group] und [user]
	\item Parameter -R ändert die Zugehörigkeit rekursiv
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{r}e\textcolor{red}{m}ove \textcolor{red}{dir}ectory}
Löschen von leeren Ordnern.
\begin{itemize}
	\item Befehl ist weniger mächtig als man erwartet
	\item Vorsicht ist geboten, auch leere Verzeichnisse können wichtig sein!!
	\item Leere Ordner in dem leeren Ordner werden auch gelöscht
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aufgabe 2)}
In der zweiten Aufgabe sollt ihr euch mit der Verwaltung von Ordnern auseinander setzen. Zur Bearbeitung stehen euch 10 Minuten zur verfügung.
{\footnotesize
\begin{itemize}
	\item wechselt in das Verzeichnis '/tmp'
	\item erstellt den Ordner 'test'
	\item guckt euch die Rechte des Ordners an
	\item entfernt die Recht für 'group' und 'all' des Ordners
	\item setzt als neuen Owner des Ordners 'root' [nur Root]
	\item versucht den Ordner zu entfernen (ohne 'sudo'). Was passiert?
	\item wechselt nun wieder den Owner zurück [nur Root]
	\item entfernt den Ordner
\end{itemize}
}
{\scriptsize Tipp: 'cd', 'ls', 'mkdir', 'chmod', 'chown', 'rmdir'}
\end{frame}

\subsection{Dateien}
\begin{frame}
\frametitle{Input, Output und Error}
\begin{itemize}
	\item Jedes Programm hat drei Datenströme:
	\begin{itemize}
		\item[1)] stdin (Standard Input [number: 0])
		\item[2)] stdout (Standard Output [number: 1])
		\item[3)] stderr (Standard Error Output [number: 2])
	\end{itemize}
	\item Bsp.: 'echo'
	\begin{itemize}[<+->]
		\item 'echo' gibt einen eingegebenen Text zurück
		\item Syntax: 'echo [text]'
		\item [text] ist stdin und die Konsole ist stdout und stderr
	\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Pipe, $<$ und $>$ }
Umleiten der Ein- und Ausgabe
\begin{itemize}[<+->]
	\item '$<$' und '$>$' laden und schreiben Dateien
	\begin{itemize}[<+->]
		\item '$>$' Schreiben in eine Datei
		\item Bsp.: 'cal $>$ test.txt'
		\item '$<$' Laden aus einer Datei
		\item Bsp.: 'less $<$ test.txt'
	\end{itemize}
	\item Pipe '$\mid$'
	\begin{itemize}[<+->]
		\item Ausgabe von Befehl $\to$ Eingabe anderer Befehl
		\item Bsp.: 'date $\mid$ less'
	\end{itemize}
	\item fancy stuff:
	\begin{itemize}[<+->]
		\item Umleiten von stderr: 2$>$ statt $>$
		\item also durch Angabe von Stream Nummer
		\item Bsp.: Umleiten von stderr auf stdout
		\begin{itemize}
			\item ls -r $>$ output.txt 2$>\&$1 
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{more}
\framesubtitle{Less than everything}
'more' ist ein Filereader
\begin{itemize}
	\item Angucken von Datei ohne Editieren
	\item Arbeitet auf Standardausgabe
	\item Beherrscht alle dem System bekannten Codierungen
	\item Navigierung ist allerdings ein wenig hinderlich
	\item Grundlage zu less
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{less}
\framesubtitle{Even more than 'more}
'less' ist intelligenter Nachfolger von 'more'
\begin{itemize}
	\item unterstützt Scrolling
	\item Navigation:
	\begin{itemize}[<+->]
		\item Pfeil- und Bildlauftasten
		\item '/pattern' Durchsucht das Dokument nach angegebenen Muster
		\item '?pattern' ist wie '/pattern' nur rückwärts
		\item '$\&$pattern' zeigt nur Zeilen, mit Muster
		\item wird pattern benutzt, dann zeigt 'n' das nächste Vorkommen
		\item ':n' ruft das nächste Dokument auf (wenn less mehrere bekommen hat)
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aufgabe 3)}
In dieser Aufgabe sollt ihr euch mit der Umleitung der Standardausgabe beschäftigen. Für die Bearbeitung habt ihr 5 Minuten.
\begin{itemize}
	{\footnotesize
	\item wechselt in euer Home-Verzeichnis
	\item lasst euch die Inhalte rekursiv ausgeben
	\item benutzt die Ausgabe als Eingabe für 'cowsay' (Pipe-Operator)
	\item lasst euch nun diese Ausgabe in die Datei 'KuhSagtHome.txt' schreiben
	\item seht euch den Inhalt der Datei an
	}
\end{itemize}
{\scriptsize Tipp: cd, ls, cowsay, $\mid$, $>$, less}
\end{frame}

\begin{frame}
\frametitle{con\textcolor{red}{cat}enate}
\framesubtitle{Was eine Katze mit Linux zu tun hat}
'cat' konkateniert und zeigt die Inhalte von Dateien
\begin{itemize}[<+->]
	\item An sich nicht mächtig, sehr einfacher Befehl
	\item Parameter
	\begin{itemize}
		\item '-n' Nummeriert die ausgegebenen Zeilen 
		\item '-s' Unterdrückt Ausgabe von sich wiederholenden Leerzeichen
	\end{itemize}
	\item Bsp.: 'cat -m output.txt'
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{head $\&$ tail}
\framesubtitle{Dateien von Kopf bis Fuß}
Ähnlich zu 'cat', sind 'head' und 'tail' einfach Textdatei Betrachter. Allerdings beschränken sich diese auf bestimmte Teile der Datei.
\begin{itemize}
	\item 'head' gibt ersten 10 Zeilen der angegebenen Datei aus
	\item 'tail' gibt letzten 10 Zeilen der angegebenen Datei aus
	\item Parameter:
	\begin{itemize}
		\item head:
		\begin{itemize}[<+->]
			\item '-n [val]' gibt ersten [val] Zeilen aus 
		\end{itemize}
		\item tail:
		\begin{itemize}[<+->]
			\item '-n [val]' analog zu head
			\item '-f' fügt weitere Zeilen zur Ausgabe hinzu, falls Inhalt weiter anwächst
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Sortieren und Suchen}
Auch wenn man beim Sortieren erst einmal an das Sortieren von Dateien denkt,
bezieht sich das Sortieren auf den Inhalt von Dateien.
Das Suchen bezieht sich auf das Finden von Dateien.
\begin{itemize}[<+->]
	\item 'sort [option] [File]' (liest die Datei File und sortiert den Inhalt)
	\begin{itemize}[<+->]
		\item '-r' Ausgabe umdrehen
		\item '-c' Check ob Inhalt von Datei sortiert ist
		\item Bsp.: 'sort -r output.txt'
	\end{itemize}
	\item 'find [path] [pattern]' (suchen nach Datei im System via Muster)
	\begin{itemize}[<+->]
		\item [Achtung!!] Suche kann lange dauern
		\item Bsp.: 'find ~ -name output.txt' (suche im Home-Folder 'output.txt')
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{c}o\textcolor{red}{p}y $\&$ \textcolor{red}{m}o\textcolor{red}{v}e}
\framesubtitle{Die Kunst des Klonens und Umbenennens}
'cp' und 'mv' sind neben 'ls' und 'cd' wohl die wichtigsten Befehle in Linux.
\begin{itemize}
	\item Dateiname muss bei beiden Befehlen nicht gleich bleiben
	\item 'mv [path1] [path2]'
	\begin{itemize}
		\item verschiebt Datei von [path1] zu [path2]
		\item Parameter:
		\begin{itemize}[<+->]
			\item '-i' (interactive) fragt vor Überschreiben
			\item '-f' (force) überschreibt \textbf{immer}
			\item '-n' (no-clobber) überschreibt \textbf{niemals}
			\item '--backup' erstellt Backup vor Überschreiben
		\end{itemize}
	\end{itemize}
	\item 'cp [path1] [path2]'
	\begin{itemize}
		\item kopiert Datei von [path1] zu [path2]
		\item Parameter:
		\begin{itemize}[<+->]
			\item selben wie 'mv'
			\item '-r' (recursive) ermöglicht verschieben von Ordnern
			\item '-s' (symbolic-link) erstellt symbolische Links, statt Dateien
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{r}e\textcolor{red}{m}ove}
\framesubtitle{Flutsch! Und weg!}
Immer wieder im Leben kommt eine Zeit in der man etwas Ballast abwerfen möchte.  
`rm` hilft dabei
\begin{itemize}[<+->]
	\item Syntax: 'rm [option] [file]'
	\item Parameter:
	\begin{itemize}[<+->]
		\item '-f' (force) es wird nicht nachgefragt und einfach alles gelöscht
		\item '-i' Nachfragen bei jeder Löschung
		\item '-r' Löschung rekursiv $\to$ (Ordner und Unterordner)
		\item '-d' leere Verzeichnisse löschen
	\end{itemize}
	\item 'rm' löscht nicht entgültig, Dateien sind nicht unleserlich
	\item soll entgültig gelöscht werden, dann benutze 'shred' (später)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{shred}
\framesubtitle{RRRRRRRRRRRRRTTZZZZZZZZZZZ!}
'shred' überschreibt Dateien und löscht sie damit entgültig
\begin{itemize}
	\item Syntax: 'shred [option] [file]'
	\item Parameter:
	\begin{itemize}[<+->]
		\item '-f' (force) Versuch Schreibrechte zu bekommen, falls benötigt
		\item '-n [num]' Anzahl [num] der Schreibvorgänge pro Datei
		\item '-u' Löschen nach dem Überschreiben
	\end{itemize}
	\item Bsp.: 'shred -u test.txt'
	\item [Achtung!!] kein Löschen von Backups, evtl. Wiederherstellung möglich
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aufgabe 4)}
Diese Aufgabe soll euch ein Gefühl für den Umgang mit Dateien geben. Für die Bearbeitung habt ihr 15 Minuten.
\begin{itemize}
	{\footnotesize
	\item sucht alle Dateien in '/usr/share' ausgeben, die dem folgenden RegEx entsprechen '".*.txt"' und schreibt diese in '/home/[username]/txt-files.txt'
	\item schaut euch nun den Inhalt an
	\item sucht nach eurer Datei 'KuhSagtHome.txt' und schreibt das Ergebnis in 'kuh-sagt-path.txt' (Suche in '/home')
	\item verbindet nun den Inhalt von 'txt-files.txt' und 'kuh-sagt-path.txt' und schreibt die Ausgabe in 'cat-files-kuh.txt'
	\item betrachtet das Ende der Datei 'cat-files-kuh.txt'. Was fällt auf?
	\item sortiert den Inhalt von 'cat-files-kuh.txt' numerisch und schreibt die Ausgabe in 'sort-cat-kuh.txt'
	\item betrachtet den Anfang von 'sort-cat-kuh.txt'. Was hat sich verändert?
	\item löscht nun alle eben erstellten Dateien
	}
\end{itemize}
{\scriptsize Tipp: find, less bzw. more, cat, tail, head, sort, rm bzw. shred}
\end{frame}


\subsection{Archive}
\begin{frame}
\frametitle{\textcolor{red}{t}ape \textcolor{red}{ar}chiver}
\framesubtitle{Archivieren}
Dateien mit .tar, .tar.gz, .zip, etc. können natürlich auch via der Oberfläche entpackt werden, allerdings kann es auch sein, dass man dies über die Konsole vornehmen muss.
\begin{itemize}[<+->]
	\item Syntax entpacken: 'tar [option] [path]'
	\item Syntax verpacken: 'tar [option] [path-archiv] [path-files]'
	\item Parameter:
	\begin{itemize}[<+->]
		\item '-c' (create) erzeugt neues Archiv
		\item '-x' (extract) extrahieren einer Datei
		\item '-v' (verbose) Fortschritt auflisten
		\item '-z' (gzip format) komprimieren als .gz, etc.
		\item '-f' erzeugt beim Entpacken einen Ordner mit Namen von Archiv
	\end{itemize}
	\item Bsp.: 'tar -xvf test.tar'
\end{itemize}
\end{frame}

\section{Prozesse}
\subsection{Prozesse verwalten}
\begin{frame}
\frametitle{htop - interaktiver Prozessmanager}
\begin{itemize}
	\item 'top'
	\begin{itemize}[<+->]
		\item ist bereits installtiert
		\item '-h' um Befehle anzeigen zu lassen
	\end{itemize}
	\item 'htop'
	\begin{itemize}[<+->]
		\item muss noch installiert werden
		\item deutlich leichtere Bedienung
	\end{itemize}
	\item Ansicht:
	\begin{itemize}[<+->]
		\item Auslastung der einzelnen CPU-Kerne und des Arbeitsspeichers
		\item Anteil vom Swap und bisherige Laufzeit des Systems
		\item PID (Prozess ID), User, PRI (Priorität), NI (Nice-Wert)
		\item VIRT und RES (benutzer virtueller und physischer Speicher)
		\item S (State; S $\in$ $\{$ S[leeping], R[unning], D[isk sleep], Z[ombie], T[raced/suspended], W[Paging] $\}$)
		\item CPU$\%$ und MEM$\%$ (genutzter CPU und Arbeitsspeicher Anteil) und TIME (bisherige Laufzeit)
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Nettigkeit}
\begin{frame}
\frametitle{nice - nette Programme}
Ausführen von Programmen mit modifizierter sheduling Priorität p, mit p $\in$ [-20,19]. Hierbei ist -20 die höchste Priorität
\begin{itemize}[<+->]
	\item Normalerweise werden Programme mit Priorität 0 gestartet
	\item Syntax: 'nice [option] [command] [arg] ...'
	\item Parameter:
	\begin{itemize}
		\item '-n (--adjustment=N)' aufaddieren von Integer N auf aktuellen Nice-Wert (Default: N=10)
	\end{itemize}
	\item Bsp. 'ping':
	\begin{itemize}[<+->]
		\item Syntax: 'ping [option] [addr]'
		\item Parameter: '-c [num]' (Anzahl der pings setzen), '-W [time]' (Timeout setzen)
		\item 'nice -n 20 ping www.foss-ag.de'
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{renice und nohup}
'renice' ermöglicht nachträgliches Einstellen des Nice-Wertes eines bereits laufenden Prozesses.
'nohup' ermöglicht es ein Programm weiterlaufen zu lassen, auch wenn der Benutzer sich ausloggt.
\begin{itemize}
	\item 'renice'
	\begin{itemize}[<+->]
		\item Syntax: 'renice [-n] priority [-g | -p | -u] identifier'
		\item '-n [num]' ist neuer Nice-Wert
		\item '-g [group-id]', '-p [process-id]', '-u [user-id]'
	\end{itemize}
	\item 'nohup'
	\begin{itemize}
		\item Syntax: 'nohup [commando] [args]'
		\item Ausgabe wird dabei in eine nohup.txt Datei im Home-Directory geschrieben (umlenken möglich)
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{$\&$ - Backstage}
Bei Angabe dieses Operators am Ende eines Prozess-Aufrufs, wird der Prozess in den Hintergrund verschoben
\begin{itemize}[<+->]
	\item Prozess blockiert Shell nicht $\to$ weiteres Arbeiten möglich
	\item Ausgabe wird aber weiterhin auf Shell geschrieben
\end{itemize}
[Achtung!!] $\&$ $\equiv$ Prozess in Hintergrund; $\&\&$ $\equiv$ Prozesse hintereinander ausführen (p1 $\&\&$ p2 : p2 wird ausgeführt, wenn p1 erfolgreich)
\end{frame}

\begin{frame}
\frametitle{Texteditoren - 1: ed, nano, pico}
\framesubtitle{You would (not) love Ed!!}
Das Bearbeiten von Textdateien ist in der Konsole schwierig. Ein Beispiel ist 'ed' (release 1970; Grundlage für 'grep').
\begin{itemize}
	\item 'pico' (release 1992):
	\begin{itemize}[<+->]
		\item sehr minimalistischer Editor
		\item reine Textverarbeitung, mehrere Dokumente möglich, Syntaxhighlighting
		\item kein Highlighting von einem Wort, kein Text-Splitscreen, keine RegEx-Suche
	\end{itemize}
	\item 'nano' (release 1999):
	\begin{itemize}[<+->]
		\item ebenfalls sehr minimalistisch
		\item Nachfolger von pico
		\item bietet mehr Funktionsumfang, z.B.: Text-Splitscreen, RegEx-Suche
	\end{itemize}
	\item 'nano' und 'pico' sind sehr minimalistisch, aber nicht zu unterschätzen
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Texteditoren - 2: vim, jed}
\framesubtitle{Good thing Ed is not around anymore}
Wir haben grad die minimaltistischen Editoren betrachtet, nun die etwas mächtigeren.
\begin{itemize}
	\item 'vim' (release 1991):
	\begin{itemize}[<+->]
		\item Großmufti unter den Editoren
		\item verbesserte Suchfunktionen, mächtiger als nano und pico
		\item Standard bei 'git'
	\end{itemize}
	\item 'jed' (release 1992):
	\begin{itemize}[<+->]
		\item \textbf{der} Editor für Programmierer
		\item liefert Templates für verschiedene Anwendungsfälle
		\item weniger mächtig als vim, aber dennoch viele Features
	\end{itemize}
	\item Bei der Wahl des Editors ist es wie immer im Leben, Geschmäcker sind verschieden
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aufgabe 5)}
In dieser Aufgabe sollt ihr euch mit der Verwaltung von Prozessen beschäftigen.
Für die Bearbeitung stehen euch 10 Minuten zur Verfügung.
\begin{itemize}
	{\footnotesize
	\item ladet euch die Datei 'infinite.tar' von 'foss-ag.de' herunter
	\item verschiebt sie nach '/tmp' und entpackt sie dort
	\item führt den Befehl 'python infinite$\_$run.py' im Hintergrund aus mit Nice-Wert 15
	\item führt 'htop' bzw. 'top' aus, sucht euren Prozess und merkt euch die PID
	\item verändert den Nice-Wert auf 10 und schaut in 'htop' bzw. 'top' nach, was passiert ist
	\item stoppt nun den Prozess mit dem Befehl 'kill', wobei ihr die PID angeben müsst
	}
\end{itemize}
{\scriptsize Tipp:  Tipp: tar, mv, nice, \&, renice, htop bzw. top}
\end{frame}

\begin{frame}
\frametitle{shutdown}
\framesubtitle{Wenn man mal das real life genießen will}
ermöglicht Ausschalten oder Neustart des Systems [nur Root]
\begin{itemize}[<+->]
	\item Syntax: 'shutdown [options] [time]'
	\item Parameter:
	\begin{itemize}[<+->]
		\item '-P' (poweroff)
		\item '-r' (reboot) 
		\item '-h' (halt) kein Timer möglich
	\end{itemize}
	\item 'sudo reboot' anstelle von 'sudo shutdown -r'
	\item Bei 'reboot' kein Timer möglich
\end{itemize}
\end{frame}

\section{Zusatz}
\begin{frame}
\frametitle{ip addr}
Meist wurde 'ifconfig' benutzt um seine lokalen IP-Adressen des Rechners anzuzeigen. Dieser Befehl ist allerdings ein wenig obsolet und wurde ersetzt durch 'ip addr'.
\begin{itemize}
	\item Um lokale IP-Adresse zu erfahren, ohne über Router zu gehen
	\item Wird benötigt, wenn man sich via 'ssh' einloggen will
	\item leider etwas unübersichtlich
	\item Parameter:
	\begin{itemize}
		\item '-4' Anzeigen der IPv4-Adressen
		\item '-6' Anzeigen der IPv6-Adressen
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{nmon}
'nmon' dient zur Überwachung der Auslastung der PC Komponenten
\begin{itemize}
	\item Elemente können der Anzeige bei Bedarf hinzugefügt und entfernt werden
	\item Shortcuts:
	\begin{itemize}[<+->]
		\item 'c' zeigt die Auslastung aller CPU Kerne an
		\item 'm' zeigt die Auslastung des Arbeitsspeichers an (auch mit SWAP)
		\item 'd' zeigt die Auslastung der Festplatte an
		\item 'k' zeigt Kernel Statistiken an (Queue, Forks, Interrupts)
		\item 'r' Details zum System und Prozessor
		\item 'l' CPU Auslastung als Graph
		\item 'n' Auslastung der Netzwerk Schnittstelle
		\item 'j' Auslastung des Dateisystems (Platz und Aufbau)
		\item 't' wie top, Auflistung aller laufenden Prozesse
		\item '+' bzw. '-' Refresh erhöhen bzw. verringern
		\item 'H' für Hilfe (Shortcuts auflisten)
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{Reg}ular \textcolor{red}{Ex}pression - 1}
\framesubtitle{The art of black magic}
Reguläre Ausdrücke sind Muster, die eine Grundstruktur von gesuchten Begriffen angeben. Um eine Fehlinterpretation der Shell zu vermeiden, sollte ein RegEx immer in Anführungszeichen angegeben werden.
\begin{itemize}
	\item Syntax - 1:
	\begin{itemize}[<+->]
		\item 'c' ein konstantes Zeichen c
		\item '.' genau \textbf{ein} beliebiges Zeichen
		\item '.*' Folge von beliebigen Zeichen (auch keines)
		\item '*' Zeichen vor * ist beliebig oft (auch gar nicht)
		\item '?' Zeichen vor ? ist \textbf{genau} einmal oder gar nicht
		\item '+' Zeichen vor + ist min. einmal
		\item '$\{$n,m$\}$' Zeichen wird n bis m mal wiederholt
		\item '$\{$n$\}$' Zeichen genau n mal
		\item '[...]' Zeichen kommt in den Klammern vor
		\item '[...-...]' Zeichen aus Zeichenklasse
		
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{\textcolor{red}{Reg}ular \textcolor{red}{Ex}pression - 2}
\framesubtitle{The art of black magic}
\begin{itemize}
	\item Syntax - 2:
	\begin{itemize}
		\item '[ $\hat{}$ ...]' und '[ $\hat{}$ ...-...]' verneinte Zeichenklasse
		\item ' $\hat{}$ ' Zeilenanfang
		\item '\$' Zeilenende
		\item '$<$' Wortanfang
		\item '$>$' Wortende
		\item 'a1$\mid$a2' alternative Ausdrücke; a1 oder a2
		\item '(...)' Gruppe von Ausdrücken
		\item '$\setminus$' Sonderbedeutung von nächstem Symbol ignorieren. Bsp.: |
	\end{itemize}
	\item Bsp.: '.*p+ython[1-99]*.*$\setminus\mid$.*$\setminus$.pyc?'
	\item Es werden alle Wörter/Dateien gesucht, die:
	\begin{itemize}
		\item 'python' im Namen haben oder mit .py bzw. .pyc aufhören
		\item dürfen mit Zahlen zwischen 1 und 99 enden
		\item min. ein p am Anfang haben
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{grep}
\framesubtitle{Gonna catch em' Strings}
Durchsucht eine Eingabe nach einem RegEx.
\begin{itemize}[<+->]
	\item Selektoren:
	\begin{itemize}[<+->]
		\item '-E' Interpretiert Suchwort als erweiterten RegEx
		\item '-F' Interpretiert Suchwort als fixed String
		\item '-G' Interpretiert Suchwort als basic RegEx
	\end{itemize}
	\item Kontrolle:
	\begin{itemize}
		\item '-f [file]' liest RegEx aus [file]
		\item '-v' invertiert das Matchmaking (alle Zeilen ohne RegEx)
		\item '-w' gibt nur Zeilen aus, in denen ganze Worte dem RegEx entsprechen
		\item '-x' gibt nur Zeilen aus, die ganz dem RegEx entsprechen
	\end{itemize}
	\item Ausgabe:
	\begin{itemize}
		\item '-c' gibt Anzahl der passenden Zeilen aus
		\item '-o' gibt nur gematchte Teile einer Zeile aus
		\item '-q' keine Ausgabe, gibt Exitcode 0 aus, wenn erfolgreich
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Aufgabe 6)}
Diese Aufgabe soll euch ein Gefühl für RegEx geben.
\begin{itemize}
{\footnotesize
	\item lasst euch eure IP-Adresse ausgeben und schreibt die Ausgabe in 'ip.txt'
	\item lasst euch nun nur die Zeilen Ausgeben, die eine valide IP-Adresse enthalten (IPv4, IPv6, oder beides)
	\item \textbf{Achtung!!} es gibt mehrere Lösungen
	}
\end{itemize}
{\scriptsize Tipp: ip addr, grep, RegEx}
\end{frame}

\end{document}